---
title: 130. 被围绕的区域
layout: post
categories:
  - 数据结构与算法
tags:
  - leetcode
abbrlink: 7415d708
date:
updated:
abstract: "本题考察如何用 DFS 或并查集解决被 'X' 包围的 'O' 区域，关键在于识别与边界相连的 'O'。"
---

# 130. 被围绕的区域

> [题目链接](https://leetcode.cn/problems/surrounded-regions/)

## 解题思路

本题的关键在于：**只有与边界相连的 `'O'` 才不会被 `'X'` 包围**。

常见解法有两种：

### 方法一：深度优先搜索（DFS）

**核心思想：**

1. 从四个边界出发，标记所有与边界相连的 `'O'`（这些无法被捕获）。
2. 遍历整个矩阵，将未被标记的 `'O'` 转换为 `'X'`（这些是被包围的），将标记恢复为 `'O'`。

**算法步骤：**

1. 处理四个边界，对每个边界上的 `'O'` 执行 DFS，标记所有相连的 `'O'` 为特殊字符 `'E'`。
2. 遍历整个矩阵：

- 将剩余的 `'O'` 改为 `'X'`（这些是被包围的）。
- 将 `'E'` 改回 `'O'`（这些是无法被包围的）。

**代码实现：**

```js
/**
 *@param {character[][]} board 输入的字符矩阵
 *@return {void} 直接修改输入矩阵，不返回值
 */
let solve = function (board) {
  let m = board.length;
  let n = board[0].length;

  // 步骤 1：从边界开始 DFS，标记所有无法被捕获的'O'
  // 处理左右边界
  for (let i = 0; i < m; i++) {
    dfs(board, i, 0); // 从左边界开始 DFS
    dfs(board, i, n - 1); // 从右边界开始 DFS
  }
  // 处理上下边界
  for (let i = 0; i < n; i++) {
    dfs(board, 0, i); // 从上边界开始 DFS
    dfs(board, m - 1, i); // 从下边界开始 DFS
  }

  // 步骤 2：处理整个矩阵
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (board[i][j] === "O") {
        // 未被标记的'O'是被包围的，将其变为'X'
        board[i][j] = "X";
      } else if (board[i][j] === "E") {
        // 被标记为'E'的是与边界相连的，恢复为'O'
        board[i][j] = "O";
      }
    }
  }
};

/**
- 用于标记所有与当前位置相连的'O'
- @param {character[][]} board 字符矩阵
- @param {number} i 当前行索引
- @param {number} j 当前列索引
*/
let dfs = function (board, i, j) {
  let m = board.length;
  let n = board[0].length;

  // 定义四个方向
  let direction = [
    [1, 0], // 下
    [0, 1], // 右
    [-1, 0], // 上
    [0, -1], // 左
  ];

  // 边界检查：超出矩阵范围则返回
  if (i < 0 || j < 0 || i >= m || j >= n) {
    return;
  }

  // 如果当前位置不是'O'，说明要么是'X'，要么已经被访问过（'E'）
  if (board[i][j] !== "O") return;

  // 标记当前'O'为'E'，表示这是一个无法被捕获的位置
  board[i][j] = "E";

  // 递归访问四个方向的相邻位置
  for (let dir of direction) {
    dfs(board, i + dir[0], j + dir[1]);
  }
};
```

### 方法二：并查集（Union-Find）

**核心思想：**

1. 创建一个虚拟节点，连接所有边界上的 `'O'`。
2. 将内部 `'O'` 与相邻的 `'O'` 连通。
3. 检查每个 `'O'` 是否与虚拟节点连通，不连通的即为被包围的。

**算法步骤：**

1. 初始化并查集，增加一个虚拟节点。
2. 将四个边界上的 `'O'` 与虚拟节点连通。
3. 遍历内部节点，将相邻的 `'O'` 连通。
4. 检查每个 `'O'`，如果与虚拟节点不连通，则转换为 `'X'`。

**代码实现：**

```js
/**
 * @param {character[][]} board 输入的字符矩阵
 * @return {void} 直接修改输入矩阵，不返回值
 */
let solve = function (board) {
  let m = board.length;
  let n = board[0].length;

  // 虚拟节点 dummy 的索引设置为 m*n，确保不会与其他节点的索引冲突
  let dummy = m * n;
  // 创建大小为 m*n+1 的并查集，额外的1个位置用于 dummy 节点
  let union = new UF(m * n + 1);

  // 步骤1：处理边界情况
  // 将四个边界上的'O'都与 dummy 节点连通
  // 处理左右边界
  for (let i = 0; i < m; i++) {
    if (board[i][0] === "O") {
      // 左边界上的'O'
      union.union(getIndex(i, 0), dummy);
    }
    if (board[i][n - 1] === "O") {
      // 右边界上的'O'
      union.union(getIndex(i, n - 1), dummy);
    }
  }
  // 处理上下边界
  for (let i = 0; i < n; i++) {
    if (board[0][i] === "O") {
      // 上边界上的'O'
      union.union(getIndex(0, i), dummy);
    }
    if (board[m - 1][i] === "O") {
      // 下边界上的'O'
      union.union(getIndex(m - 1, i), dummy);
    }
  }

  // 定义四个方向：上、下、左、右
  let direction = [
    [-1, 0], // 上
    [1, 0], // 下
    [0, -1], // 左
    [0, 1], // 右
  ];

  // 步骤2：处理内部节点
  // 遍历除边界外的所有格子
  for (let i = 1; i < m - 1; i++) {
    for (let j = 1; j < n - 1; j++) {
      if (board[i][j] === "O") {
        // 对于每个'O'，检查其四个方向
        for (let dir of direction) {
          let x = i + dir[0];
          let y = j + dir[1];
          // 如果相邻位置也是'O'，则将两个位置连通
          if (board[x][y] === "O") {
            union.union(getIndex(i, j), getIndex(x, y));
          }
        }
      }
    }
  }

  // 步骤3：替换被包围的'O'
  // 遍历除边界外的所有格子
  for (let i = 1; i < m - 1; i++) {
    for (let j = 1; j < n - 1; j++) {
      if (board[i][j] === "O") {
        // 如果一个'O'和 dummy 不连通，说明它被包围了
        if (!union.connected(getIndex(i, j), dummy)) {
          board[i][j] = "X";
        }
      }
    }
  }

  function getIndex(i, j) {
    return i * n + j;
  }
};

class UF {
  // n 为图中节点的个数
  constructor(n) {
    // 连通分量个数
    this._count = n;
    // 存储每个节点的父节点
    this.parent = Array.from({ length: n }, (_, index) => index);
  }

  // 将节点 p 和节点 q 连通
  union(p, q) {
    const rootP = this.find(p);
    const rootQ = this.find(q);

    if (rootP === rootQ) {
      return;
    }

    this.parent[rootQ] = rootP;
    // 两个连通分量合并成一个连通分量
    this._count--;
  }

  // 判断节点 p 和节点 q 是否连通
  connected(p, q) {
    const rootP = this.find(p);
    const rootQ = this.find(q);
    return rootP === rootQ;
  }

  // 路径压缩
  find(x) {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]);
    }
    return this.parent[x];
  }

  // 返回图中的连通分量个数
  count() {
    return this._count;
  }
}
```
